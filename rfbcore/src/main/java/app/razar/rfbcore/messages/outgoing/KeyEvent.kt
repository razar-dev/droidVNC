/*
 * This file is part of the droidVNC distribution (https://github.com/razar-dev/VNC-android).
 * Copyright © 2022 Sachindra Man Maskey.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package app.razar.rfbcore.messages.outgoing

import io.ktor.utils.io.*
import java.nio.ByteBuffer

/**
 * A key press or release. Down-flag is non-zero (true) if the key is now pressed,
 * zero (false) if it is now released. The key itself is specified using the “keysym”
 * values defined by the X Window System.
 * No. of bytes 	Type 	[Value] 	Description
 * 1 	            U8 	    4 	        message-type
 * 1 	            U8 	  	            down-flag
 * 2 	              	  	            padding
 * 4 	            U32 	  	        key
 *
 * Auto repeating of keys when a key is held down should be handled on the client.
 * The rationale being that high latency on the network can make it seem like a key is
 * being held for a very long time, yet the problem is that the KeyEvent message
 * releasing the button has been delayed.
 *
 * The client should send only repeated “down” KeyEvent messages, no “up” messages,
 * when a key is automatically repeated. This allows the server to tell the difference
 * between automatic repeat and actual repeated entry by the user.
 *
 * For most ordinary keys, the “keysym” is the same as the corresponding ASCII value.
 * For full details, see The Xlib Reference Manual, published by O’Reilly & Associates,
 * or see the header file <X11/keysymdef.h> from any X Window System installation.
 * Some other common keys are:
 *
 * Key name 	        Keysym value
 * BackSpace 	        0xff08
 * Tab 	                0xff09
 * Return or Enter 	    0xff0d
 * Escape 	            0xff1b
 * Insert 	            0xff63
 * Delete 	            0xffff
 * Home 	            0xff50
 * End 	                0xff57
 * Page Up 	            0xff55
 * Page Down 	        0xff56
 * Left 	            0xff51
 * Up 	                0xff52
 * Right 	            0xff53
 * Down 	            0xff54
 * F1 	                0xffbe
 * F2 	                0xffbf
 * F3 	                0xffc0
 * F4 	                0xffc1
 * ... 	...
 * F12 	                0xffc9
 * Shift (left) 	    0xffe1
 * Shift (right) 	    0xffe2
 * Control (left) 	    0xffe3
 * Control (right) 	    0xffe4
 * Meta (left) 	        0xffe7
 * Meta (right) 	    0xffe8
 * Alt (left) 	        0xffe9
 * Alt (right) 	        0xffea
 *
 * The interpretation of keysyms is a complex area. In order to be as widely
 * interoperable as possible the following guidelines should be used:
 *
 * The “shift state” (i.e. whether either of the Shift keysyms are down) should only
 * be used as a hint when interpreting a keysym. For example, on a US keyboard
 * the ‘#’ character is shifted, but on a UK keyboard it is not. A server with a US
 * keyboard receiving a ‘#’ character from a client with a UK keyboard will not have
 * been sent any shift presses. In this case, it is likely that the server will
 * internally need to “fake” a shift press on its local system, in order to get a ‘#’
 * character and not, for example, a ‘3’.
 * The difference between upper and lower case keysyms is significant. This is unlike
 * some of the keyboard processing in the X Window System which treats them as the same.
 * For example, a server receiving an uppercase ‘A’ keysym without any shift presses
 * should interpret it as an uppercase ‘A’. Again this may involve an internal “fake” shift press.
 * Servers should ignore “lock” keysyms such as CapsLock and NumLock where possible.
 * Instead they should interpret each character-based keysym according to its case.
 * Unlike Shift, the state of modifier keys such as Control and Alt should be taken
 * as modifying the interpretation of other keysyms. Note that there are no keysyms
 * for ASCII control characters such as ctrl-a; these should be generated by viewers
 * sending a Control press followed by an ‘a’ press.
 * On a viewer where modifiers like Control and Alt can also be used to generate character-based keysyms,
 * the viewer may need to send extra “release” events in order that the keysym is interpreted correctly.
 * For example, on a German PC keyboard, ctrl-alt-q generates the ‘@’ character. In this case, the viewer
 * needs to send “fake” release events for Control and Alt in order that the ‘@’ character is interpreted
 * correctly (ctrl-alt-@ is likely to mean something completely different to the server).
 * There is no universal standard for “backward tab” in the X Window System. On some systems shift+tab
 * gives the keysym “ISO Left Tab”, on others it gives a private “BackTab” keysym and on others it gives “Tab”
 * and applications tell from the shift state that it means backward-tab rather than forward-tab.
 * In the RFB protocol the latter approach is preferred. Viewers should generate a shifted Tab rather
 * than ISO Left Tab. However, to be backwards-compatible with existing viewers, servers should also
 * recognise ISO Left Tab as meaning a shifted Tab.
 *
 */
class KeyEvent(private val code: Int, private val down: Boolean): OutgoingMessage {
    override suspend fun sendMessage(outputStream: ByteWriteChannel) {
        val byteArray = ByteArray(1 + 1 + 2 + 4)

        // Set the message type
        byteArray[0] = this.messageId.toByte()
        byteArray[1] = if (down) 1 else 0

        val int = ByteBuffer.allocate(4).putInt(code).array()
        System.arraycopy(int, 0, byteArray, 4, 4)
        outputStream.writeFully(byteArray)
    }

    override val messageId: Int = 4
}